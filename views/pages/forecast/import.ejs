<%- include('../../partials/header') %>

<link rel="stylesheet" href="/lib/DataTables/datatables.min.css"/>
<section class="content-block light-grey">
  <h1>Import</h1>

        <h2>Select import type</h2>
        <!--<form id="schemaForm">-->

            <label for="schemaType">Schema Type:</label>
            <select id="schemaType" name="schemaType"></select>
            <br>

            <!-- Project dropdown for task imports -->
            <div id="projectSelection" style="display: none;">
                <label for="projectId">Project:</label>
                <select id="projectId" name="projectId">
                    <option value="">Select a project...</option>
                </select>
                <br>
            </div>

            <label for="csvFile">CSV File:</label>
            <input type="file" id="csvFile" name="csvFile">
            <br>

            <h2>Import preview</h2>
            <table id="csvPreview" style="display: none;">
            <!-- The table will be populated dynamically -->
            </table>
            <br/>
            <button id="submit" type="submit" style="display:none;">Import</button>
            <br/>
        <!--</form>-->
</section>
<script src="/lib/jquery-3.7.1.min.js"></script>
<script src="/lib/DataTables/datatables.min.js"></script>
<script src="/lib/jquery.csv.min.js"></script>
<script src="/lib/ajv7.min.js"></script>

<script>
    // Function to render the data table with validation status
    const validatedRows = [];
    function renderDataTable(columnTitles, rows) {
      const table = $('#csvPreview');
      table.empty();

      // Add table headers with column titles
      const thead = $('<thead></thead>');
      const headerRow = $('<tr></tr>');
      columnTitles.forEach(columnTitle => {
        const th = $('<th></th>').text(columnTitle);
        headerRow.append(th);
      });
      // Add a new column for the validation status
      headerRow.append('<th>Validation Status</th>');
      thead.append(headerRow);
      headerRow.append('<th>Import Status</th>');
      headerRow.append('<th>Imported ID</th>');
      thead.append(headerRow);
      table.append(thead);

              // Add table rows with data and validation status
        const tbody = $('<tbody></tbody>');
        rows.forEach(row => {
          const tr = $('<tr></tr>');
          columnTitles.forEach(columnTitle => {
            const td = $('<td></td>');
            if (columnTitle === 'description') {
                const cellText = row.data[columnTitle].replace(/ \| /g, '<br/>')
                td.html(cellText);
            } else if (columnTitle === 'assigned_persons') {
                // Show email lookup information
                let cellContent = '';
                if (row.data._emailLookupInfo) {
                    const info = row.data._emailLookupInfo;
                    if (info.found && info.found.length > 0) {
                        cellContent += `<strong>Found IDs:</strong> ${info.found.join(', ')}<br>`;
                    }
                    if (info.notFound && info.notFound.length > 0) {
                        cellContent += `<strong style="color: red;">Not Found:</strong> ${info.notFound.join(', ')}`;
                    }
                } else {
                    cellContent = row.data[columnTitle] || '';
                }
                td.html(cellContent);
            } else {
                td.text(row.data[columnTitle]);
            }
            tr.append(td);
          });
          // Add a new cell for the validation status
          const validationStatusCell = $('<td></td>').text(row.isValid);
          tr.append(validationStatusCell);

          const importStatusCell = $('<td id="import-'+row.id+'"></td>');
          tr.append(importStatusCell);

          const importIDCell = $('<td id="importID-'+row.id+'"></td>');
          tr.append(importIDCell);


          tbody.append(tr);
        });
      table.append(tbody);

      // Show the table
      table.show();

      createDataTable();

      // Enable the import button if there is valid data
      const importButton = $('#submit');
      const isValidData = rows.every(row => row.isValid);
      if (isValidData) {
        importButton.prop('disabled', !isValidData);
        importButton.show();
        importButton.on('click', function(event){
          event.preventDefault();
          importData();
        });
      }
    }

    function createDataTable() {
      var doscroll = false;
      const dataTable = $('#csvPreview').DataTable({
        dom: 'Bfrtip',
        pageLength: 50,
        scrollX: doscroll,
        buttons: [
            'copy',
            'excel',
            'csv',
            'pdf'
        ]
      });
    }

    // CSP-compliant custom validator (replaces AJV to avoid Function() constructor)
    function validateRow(row, schema) {
      const errors = [];
      
      // Check required fields
      if (schema.required) {
        for (const field of schema.required) {
          if (!(field in row) || row[field] === null || row[field] === undefined || row[field] === '') {
            errors.push({
              instancePath: `/${field}`,
              schemaPath: `#/required`,
              keyword: 'required',
              params: { missingProperty: field },
              message: `must have required property '${field}'`
            });
          }
        }
      }
      
      // Validate properties
      if (schema.properties) {
        for (const [propName, propSchema] of Object.entries(schema.properties)) {
          const value = row[propName];
          
          // Skip validation if property is not present (unless required)
          if (value === undefined || value === null || value === '') {
            continue;
          }
          
          // Type validation
          if (propSchema.type) {
            const expectedType = propSchema.type;
            let actualType = typeof value;
            
            // Handle special cases
            if (expectedType === 'integer' && actualType === 'number') {
              if (!Number.isInteger(value)) {
                errors.push({
                  instancePath: `/${propName}`,
                  schemaPath: `#/properties/${propName}/type`,
                  keyword: 'type',
                  params: { type: 'integer' },
                  message: `must be integer`
                });
                continue;
              }
            } else if (expectedType === 'array' && !Array.isArray(value)) {
              errors.push({
                instancePath: `/${propName}`,
                schemaPath: `#/properties/${propName}/type`,
                keyword: 'type',
                params: { type: 'array' },
                message: `must be array`
              });
              continue;
            } else if (expectedType === 'boolean' && actualType !== 'boolean') {
              errors.push({
                instancePath: `/${propName}`,
                schemaPath: `#/properties/${propName}/type`,
                keyword: 'type',
                params: { type: 'boolean' },
                message: `must be boolean`
              });
              continue;
            } else if (expectedType === 'number' && actualType !== 'number') {
              errors.push({
                instancePath: `/${propName}`,
                schemaPath: `#/properties/${propName}/type`,
                keyword: 'type',
                params: { type: 'number' },
                message: `must be number`
              });
              continue;
            } else if (expectedType === 'string' && actualType !== 'string') {
              errors.push({
                instancePath: `/${propName}`,
                schemaPath: `#/properties/${propName}/type`,
                keyword: 'type',
                params: { type: 'string' },
                message: `must be string`
              });
              continue;
            }
          }
          
          // Validate array items if property is an array
          if (propSchema.type === 'array' && propSchema.items && Array.isArray(value)) {
            const itemType = propSchema.items.type;
            for (let i = 0; i < value.length; i++) {
              const item = value[i];
              if (itemType === 'integer' && !Number.isInteger(item)) {
                errors.push({
                  instancePath: `/${propName}/${i}`,
                  schemaPath: `#/properties/${propName}/items/type`,
                  keyword: 'type',
                  params: { type: 'integer' },
                  message: `must be integer`
                });
              }
            }
          }
          
          // Validate numeric constraints
          if ((propSchema.type === 'number' || propSchema.type === 'integer') && typeof value === 'number') {
            if (propSchema.exclusiveMinimum !== undefined && value <= propSchema.exclusiveMinimum) {
              errors.push({
                instancePath: `/${propName}`,
                schemaPath: `#/properties/${propName}/exclusiveMinimum`,
                keyword: 'exclusiveMinimum',
                params: { limit: propSchema.exclusiveMinimum },
                message: `must be > ${propSchema.exclusiveMinimum}`
              });
            }
            if (propSchema.minimum !== undefined && value < propSchema.minimum) {
              errors.push({
                instancePath: `/${propName}`,
                schemaPath: `#/properties/${propName}/minimum`,
                keyword: 'minimum',
                params: { limit: propSchema.minimum },
                message: `must be >= ${propSchema.minimum}`
              });
            }
          }
        }
      }
      
      if (errors.length > 0) {
        console.error('CSV data validation errors:', errors);
        return false;
      }
      
      return true;
    }

    // Function to validate CSV data against the schema using custom CSP-compliant validator
    async function validateCSV(csvData, schemaType) {
      try {
        // Fetch the schema file based on the schemaType
        const response = await fetch(`/forecast/schemas/${schemaType}`);
        if (!response.ok) {
          throw new Error('Failed to fetch the schema.');
        }

        const schema = await response.json();

        // Extract column titles from the first row of the CSV data
        const columnTitles = csvData[0];

        // Validate each row individually
        for (let i = 1; i < csvData.length; i++) {
          const row = csvData[i];
          const jsonObject = {};
          columnTitles.forEach((columnTitle, index) => {
            const columnType = schema.properties[columnTitle].type; // Get the data type from the schema
            const cellValue = row[index];

            // Convert the value to the appropriate data type based on the schema
            if (cellValue != '') {
              if (columnType === 'integer') {
                jsonObject[columnTitle] = parseInt(cellValue, 10);
              } else if (columnType === 'number') {
                jsonObject[columnTitle] = parseFloat(cellValue);
              } else if (columnType === 'boolean') {
                jsonObject[columnTitle] = cellValue.toLowerCase() === 'true';
              } else if (columnType === 'array') {
                // Split the comma-separated values and convert items to the appropriate data type
                const items = cellValue.split(',').map(item => item.trim());
                jsonObject[columnTitle] = items.map(item => {
                  // Convert each item to the appropriate data type
                  if (!isNaN(item)) {
                    return parseFloat(item); // Assume it's a number if it can be parsed as one
                  } else if (item.toLowerCase() === 'true' || item.toLowerCase() === 'false') {
                    return item.toLowerCase() === 'true'; // Convert to boolean if it's "true" or "false"
                  } else {
                    return item; // Otherwise, treat as a string
                  }
                });
              } else {
                jsonObject[columnTitle] = cellValue;
              }
            }
          });

          // For task imports, we don't need to validate project_id from CSV since it comes from dropdown
          if (schemaType === 'task' && jsonObject.hasOwnProperty('project_id')) {
            delete jsonObject.project_id;
          }

          // Handle assigned_persons email lookup for task imports
          if (schemaType === 'task' && jsonObject.hasOwnProperty('assigned_persons') && Array.isArray(jsonObject.assigned_persons)) {
            try {
              // Build query string for multiple emails
              const emailParams = jsonObject.assigned_persons.map(email => `email=${encodeURIComponent(email)}`).join('&');
              const emailLookupResponse = await fetch(`/forecast/persons?${emailParams}`, {
                method: 'GET',
                headers: {
                  'Accept': 'application/json',
                },
              });

              if (emailLookupResponse.ok) {
                const lookupResult = await emailLookupResponse.json();
                if (lookupResult.success) {
                  jsonObject.assigned_persons = lookupResult.data.personIds;
                  // Store validation info for display
                  jsonObject._emailLookupInfo = {
                    found: lookupResult.data.personIds,
                    notFound: lookupResult.data.notFoundEmails,
                    allFound: lookupResult.data.allFound
                  };
                } else {
                  console.error('Email lookup failed:', lookupResult.error);
                }
              } else {
                console.error('Email lookup request failed:', emailLookupResponse.status);
              }
            } catch (error) {
              console.error('Error during email lookup:', error);
            }
          }

          const isValidRow = validateRow(jsonObject, schema);
          validatedRows.push({ data: jsonObject, isValid: isValidRow, id: i });
        }

        // Render the data table with validation status
        renderDataTable(columnTitles, validatedRows);

        return validatedRows.every(row => row.isValid);
      } catch (error) {
        console.error('Error validating CSV data:', error);
        return false;
      }
    }

    async function performImport(schemaType, object) {
      // Testing only
      /*
      var responseData = { id: 19 }
      return { success: true, data: responseData };
      */
      try {
        const tokenMeta = document.querySelector('meta[name="csrf-token"]');
        const csrfToken = tokenMeta ? tokenMeta.getAttribute('content') : '';
        const response = await fetch('/forecast/tasks', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken,
          },
          body: JSON.stringify(object),
        });

        const responseData = await response.json();
        if (!response.ok) {
          throw new Error(responseData.error);
        }

        return { success: true, data: responseData.data };
      } catch (error) {
        console.error('Import failed:', error);
        return { success: false, error: error};
      }
    }

    // Function to perform the import when the import button is pressed
    async function importData() {
      const selectedSchema = $('#schemaType').val();
      const projectId = $('#projectId').val();
      
      // Validate project selection for task imports
      if (selectedSchema === 'task' && !projectId) {
        alert('Please select a project for task import.');
        return;
      }
      
      for (const row of validatedRows) {
        // Add project_id to the data if importing tasks
        let importData = { ...row.data };
        if (selectedSchema === 'task' && projectId) {
          importData.project_id = parseInt(projectId);
        }
        
        // Clean up temporary email lookup info before import
        if (importData._emailLookupInfo) {
          delete importData._emailLookupInfo;
        }
        
        result = await performImport(selectedSchema, importData);
        console.log(result);
        importStatusCell = $("#import-" + row.id);
        importIDCell = $("#importID-" + row.id);
        if (result.success) {
          importStatusCell.text('SUCCESS');
          console.log(result.data);
          if (result.data && result.data.id) {
            // If the import was successful and the task has an ID, create a hyperlink
            // Use the correct Forecast URL format with project and task IDs
            const projectId = $('#projectId').val();
            const selectedOption = $('#projectId option:selected');
            const companyProjectId = selectedOption.attr('data-company-project-id') || projectId;
            const taskUrl = `https://app.forecast.it/project/${companyProjectId}/task-board/T${result.data.company_task_id}`;
            const taskId = result.data.company_task_id;
            const taskLink = $('<a></a>').attr('href', taskUrl).text(taskId);
            taskLink.attr('target','_blank');
            importStatusCell.empty().html("SUCCESS");
            importIDCell.empty().append(taskLink);
          }
        } else {
          importStatusCell.text('FAILED | '+ result.error);
        }
      };
      const dataTable = $('#csvPreview').DataTable();
      dataTable.destroy();
      createDataTable();
    }

    // Fetch the available schemas and populate the select dropdown
    fetch('/forecast/schemas', {
        headers: {
        'Accept': 'application/json'
        }
    })
    .then(response => response.json())
    .then(schemas => {
        const schemaTypeSelect = document.getElementById('schemaType');
        schemas.forEach(schema => {
        const option = document.createElement('option');
        option.value = schema;
        option.textContent = schema;
        schemaTypeSelect.appendChild(option);
        });
    })
    .catch(error => {
        console.error('Error fetching schemas:', error);
        alert('Error fetching schemas. Please try again later.');
    });

    // Fetch projects for the project dropdown
    fetch('/forecast/projects', {
        headers: {
        'Accept': 'application/json'
        }
    })
    .then(response => response.json())
    .then(projects => {
        // Extract the actual projects array from the response
        const projectsArray = projects.data || projects;
        window.availableProjects = projectsArray; // Store projects globally
        const projectSelectionDiv = $('#projectSelection');
        
        if (projectsArray.length > 0) {
            projectSelectionDiv.show();
            const projectIdSelect = document.getElementById('projectId');
            projectIdSelect.innerHTML = '<option value="">Select a project...</option>';
            
            projectsArray.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                option.setAttribute('data-company-project-id', project.company_project_id);
                option.textContent = `${project.name}`;
                projectIdSelect.appendChild(option);
            });
        } else {
            projectSelectionDiv.hide();
        }
    })
    .catch(error => {
        console.error('Error fetching projects:', error);
        alert('Error fetching projects. Please try again later.');
    });

    // Show/hide project dropdown based on schema type
    $('#schemaType').change(function() {
        const selectedSchema = $(this).val();
        const projectSelectionDiv = $('#projectSelection');
        
        if (selectedSchema === 'task') {
            projectSelectionDiv.show();
        } else {
            projectSelectionDiv.hide();
        }
    });



    // Submit form event listener
    $('#csvFile').change(async () => {
      const selectedSchema = $('#schemaType').val();
      const csvFile = $('#csvFile')[0].files[0];

      if (!csvFile) {
        alert('Please select a CSV file.');
        return;
      }

      // Show/hide project dropdown based on schema type
      const projectSelectionDiv = $('#projectSelection');
      if (selectedSchema === 'task') {
        projectSelectionDiv.show();
      } else {
        projectSelectionDiv.hide();
      }

      const reader = new FileReader();
      reader.onload = async function (e) {
        const csvData = $.csv.toArrays(e.target.result);
        const isValidCSV = await validateCSV(csvData, selectedSchema);
      };
      reader.readAsText(csvFile);
    });
</script>
<%- include('../../partials/footer') %>
